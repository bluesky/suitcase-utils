from bluesky.tests.conftest import RE # noqa
from ophyd.tests.conftest import hw # noqa
from . import SuitcaseUtilsUnknownEventType
import event_model
from bluesky.plans import count
import pytest


@pytest.fixture(params=['event', 'bulk_events', 'event_page'],
                scope='function')
def image_data(RE, hw, request):
    return  events_data(RE, hw, det='direct_img', event_type=request.param)


@pytest.fixture(params=['event', 'bulk_events', 'event_page'],
                scope='function')
def scalar_data(RE, hw, request):
    return events_data(RE, hw, det='det', event_type=request.param)


def events_data(RE, hw, det='det', event_type='event'):
    '''Generates data to be used for testing of suitcase.*.export(..) functions

    Parameters
    ----------
    RE : object
        bluesky.RunEngine object to be used to generate the data.
    hw : object
        ophyd.sim.hw object from which to extract simulated detectors and
        motors.
    det : string
        The name of the detector to use to generate the data.
    event_type : string
        The event type to return (can be 'event', 'bulk_events' or
        'event_page')
    Returns
    -------
    collector : list
        A list of (name, doc) tuple pairs generated by the run engine.
    '''

    # define the output lists and an internal list.
    collector = []
    event_list = []

    # define the collector function depending on the event_type
    if event_type == 'event':
        def collect(name, doc):
            collector.append((name, doc))
            if name == 'event':
                event_list.append(doc)
    elif event_type == 'event_page':
        def collect(name, doc):
            if name == 'event':
                event_list.append(doc)
            elif name == 'stop':
                collector.append(('event_page',
                                  event_model.pack_event_page(*event_list)))
                collector.append((name, doc))
            else:
                collector.append((name, doc))
    elif event_type == 'bulk_events':
        def collect(name, doc):
            if name == 'event':
                event_list.append(doc)
            elif name == 'stop':
                collector.append(('bulk_events', {'primary': event_list}))
                collector.append((name, doc))
            else:
                collector.append((name, doc))
    else:
        raise SuitcaseUtilsUnknownEventType('Unknown event_type kwarg passed '
                                            'to suitcase.utils.events_data')

    # collect the documents
    RE.subscribe(collect)
    RE(count([getattr(hw, det)], 5))

    expected = create_expected(collector, event_list)

    return collector, expected


def create_expected(collector, event_list):
    '''Generates the expected dictionary used intesting from a collector list

    Parameters
    ----------

    collector : list
        A list of (name, doc) tuple pairs generated by the run engine.

    Returns
    -------
    expected : dict
        A dictionary with the schema:
            {'metadata': {'start': start_doc, 'stop': stop_doc,
                          'descriptors': {'primary': 'descriptor'}},
             'primary': {'seq_num': [], 'uid': [], 'time': [],
                         'timestamps': {det_name:[]},
                         'data': {det_name:[]}}}

        .. note::

            This schema was chosen as the API is very similar to the
            intake-databroker API

    '''

    # create the expected dictionary from the documents
    docs = (doc for name, doc in collector)
    start, descriptor, *data_events, stop = docs
    expected = {}
    det_name = list(descriptor['data_keys'].keys())[0]  # There is only one
    expected['primary'] = {'data': {det_name: []}, 'seq_num': [], 'time': [],
                           'uid': [], 'timestamps': {'img': []}}
    for event in event_list:
        expected['primary']['data'][det_name].append(event['data'][det_name])
        expected['primary']['timestamps'][det_name].append(
            event['timestamps'][det_name])
        expected['primary']['seq_num'].append(event['seq_num'])
        expected['primary']['time'].append(event['time'])
        expected['primary']['uid'].append(event['uid'])

    expected['metadata'] = {'start': start, 'stop': stop,
                            'descriptors': {'primary': descriptor}}

    # ensure that the returned data is a built-in python type:
    for i, val in enumerate(expected['primary']['data'][det_name]):
        expected['primary']['data'][det_name][i] = event_model._sanitize_numpy(
            val)

    return expected
